---
title: Slots
description: Learn about the slots provided in the Product Details dropin.
sidebar:
  order: 5
---

A Slot is a high-level interface for developers to define and manage dynamic content insertion within drop-in components.

## Context

The context is defined during implementation of a drop-in and can be used to pass data and functions to the slot.

### Pre-built Methods

- **dictionary**: The dictionary of the selected language.
- **replaceWith**: A function to replace the slot's content with a new HTML element.
- **appendChild**: A function to append a new HTML element to the slot's content.
- **prependChild**: A function to prepend a new HTML element to the slot's content.
- **appendSibling**: A function to append a new HTML element after the slot's content.
- **prependSibling**: A function to prepend a new HTML element **before** the slot's content.
- **getSlotElement**: A function to get a slot element.
- **onChange**: A function to listen to changes in the slot's context.

---

## Implementing a new slot

The `<Slot />` component is used to define a slot in a container. It receives a name and a slot object with the following properties:

### name

The name of the slot in _PascalCase_. `string` (required).

### slot (required)

- `ctx`: An object representing the context of the slot, including methods for manipulating the slot's content.

The slot property gives developers flexibility in dynamically generating and manipulating content within slots,
allowing for a customizable and dynamic user interface in the drop-in component.

### context

The context property in the Slot component lets developers pass extra information or functionality to customize how the slot
behaves or interacts with the application. This information is accessible within the slot's rendering logic, allowing for
tailored slot behavior based on specific needs or application states.

### render

The render property in the Slot component lets developers define how the content within the slot should be displayed and should be used when developers
need fine-grained control over what content appears within the slot.
It's particularly useful when using custom slot methods (see Privates below) in scenarios where the content to be displayed within the slot is dynamic and may depend on
properties passed to another component.

### children

The children property in the Slot component represents the content that is passed directly within the opening and closing tags of the Slot component.
It allows developers to include static content directly within the slot, which will be rendered as part of the slot's contents.
This property is useful for cases where the content within the slot is static or does not need to be dynamically generated by the slot.

```tsx
// MyContainer.tsx (Drop-in)

import { HTMLAttributes } from 'preact/compat';
import { Container, Slot, SlotProps } from '@adobe/elsie/lib';

export interface MyContainerProps extends HTMLAttributes<HTMLDivElement> {
  slots?: {
    MyOpenSlot?: SlotProps<{
      // MyOpenSlot Context
      data: MyContainerData;
    }>;
  };
}

export const MyContainer: Container<MyContainerProps> = ({ slots, children, ...props }) => {
  // ...

  return (
    <div {...props}>
      <Slot name="MyOpenSlot" slot={slots?.MyOpenSlot} context={{ data }} />
    </div>
  );
};
```

```js
provider.render(MyContainer, {
  slots: {
    MyOpenSlot: (ctx) => {
      // create a new HTML element
      const element = document.createElement('div');
      // set the innerHTML of the new element to the text from the context's data
      element.innerHTML = ctx.data.text;

      // append the new element to the slot's content
      ctx.appendChild(element);

      // ...or you could also use any of the other slot methods to manipulate the slot's content
      // ctx.replaceWith(element);
      // ctx.prependChild(element);
      // ctx.appendSibling(element);
      // ctx.prependSibling(element);

      // to listen and react to changes in the slot's context (lifecycle)
      ctx.onChange((next) => {
        // update the innerHTML of the new element to the new text from the context's data
        element.innerHTML = ctx.data.text;
      });
    },
  },
});
```

## Privates

The `<Slot />` component has a private interface that serves as a mechanism for managing internal
complexity and promoting clean, modular design within the Slot component or related components.

### \_registerMethod

The `_registerMethod` private function is used to register a method in the slot's context which is particularly helpful in scenarios
where dynamic behavior or interactions need to be incorporated into the Slot component.

Slot Methods also include the ability to modify the slot's state or content based on external interactions or changes in application state.

### \_setProps

The `_setProps` private function within the Slot component is responsible for dynamically updating the properties of the slot.
It allows developers to modify the slot's state or content based on external interactions or changes in application state,
triggering re-renders of the slot component with updated properties.

### \_htmlElementToVNode

The `_htmlElementToVNode` private function in the Slot component converts HTML elements into virtual DOM nodes (VNodes),
enabling their integration into Preact components. This conversion facilitates the dynamic insertion of HTML content
into slots while benefiting from Preact's virtual DOM reconciliation and rendering.

```tsx
// MyContainer.tsx (Drop-in)

<Slot
  name="MyOpenSlot"
  slot={slots?.MyOpenSlot}
  context={{
    // custom slot method
    appendButton(callback) {
      // use _registerMethod to register a method in the slot's context
      this._registerMethod((...attrs) => {
        // callback return the values provided by the storefront developer
        const { text, ...buttonProps } = callback(...attrs);

        const button = (
          <Button type="button" {...buttonProps}>
            {text}
          </Button>
        );

        // use _setProps to update the slot's properties
        this._setProps((prev: any) => ({
          children: [...(prev.children || []), button],
        }));
      });
    },
  }}
  render={(props) => {
    // render the slot's content using props mutated by the slot's methods
    return <Buttons>{props.children}</Buttons>;
  }}
/>
```

```js
// blocks/my-block.js (storefront)

provider.render(MyContainer, {
  slots: {
    // Available Slots
    MyOpenSlot: (ctx) => {
      ctx.appendButton: (next, state) => {
        // use state to get the current state of the slot
        const loading = state.get('loading');

        return {
          text: loading ? 'Loading' : 'Click me!',
          onClick: async () => {
            // use state to update the state of the slot
            state.set('loading', true);

            await doSomething().finally(() => {
              state.set('loading', false);
            });
          },
        };
      },
    },
  },
});
```
